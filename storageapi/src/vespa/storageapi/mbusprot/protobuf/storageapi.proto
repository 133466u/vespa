// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
syntax = "proto3";

option cc_enable_arenas = true;

package storage.mbusprot.protobuf;

// Note: we use a *Request/*Response naming convention rather than *Command/*Reply,
// as the former is the gRPC convention and that's where we intend to move.

// Next tag to use: 2
message BucketSpace {
   uint64 space_id = 1;
}

// Next tag to use: 2
message BucketId {
   fixed64 raw_id = 1;
}

// Next tag to use: 3
message Bucket {
    uint64  space_id      = 1;
    fixed64 raw_bucket_id = 2;
}

// Next tag to use: 9
message BucketInfoV1 {
    uint64  last_modified_timestamp = 1;
    // TODO version the checksum instead?
    fixed32 checksum       = 2;
    uint32  doc_count      = 3;
    uint32  total_doc_size = 4;
    uint32  meta_count     = 5;
    uint32  used_file_size = 6;
    bool    ready          = 7;
    bool    active         = 8;
}

// Next tag to use: 10
message BucketInfoV2 {
    uint64  last_modified_timestamp = 1;
    // TODO version the checksum instead?
    fixed64 checksum_lo    = 2;
    fixed64 checksum_hi    = 3;
    uint32  doc_count      = 4;
    uint32  total_doc_size = 5;
    uint32  meta_count     = 6;
    uint32  used_file_size = 7;
    bool    ready          = 8;
    bool    active         = 9;
}

// Next tag to use: 3
message BucketInfo {
    BucketInfoV1 info_v1 = 1;
    BucketInfoV2 info_v2 = 2;
}

message GlobalId {
    // 96 bits of GID data in _little_ endian.
    fixed64 lo_64 = 1;
    fixed32 hi_32 = 2;
}

// TODO these should ideally be gRPC headers..
message RequestHeader {
    uint64  message_id   = 1;
    uint32  priority     = 2; // Always in range [0, 255]
    uint32  source_index = 3; // Always in range [0, 65535]
    fixed32 loadtype_id  = 4;
}

// TODO these should ideally be gRPC headers..
message ResponseHeader {
    // TODO this should ideally be gRPC Status...
    uint32 return_code_id      = 1;
    bytes  return_code_message = 2; // FIXME it's `bytes` since `string` will check for UTF-8... might not hold...
    uint64 message_id          = 3;
    uint32 priority            = 4; // Always in range [0, 255]
}

// TODO extract bucket info response fields to own message!

message Document {
    bytes payload = 1;
}

message DocumentId {
    bytes id = 1;
}

message TestAndSetCondition {
    bytes selection = 1;
}

// Next tag to use: 6
message PutRequest {
    Bucket   bucket                 = 1;
    Document document               = 2;
    uint64   new_timestamp          = 3;
    uint64   expected_old_timestamp = 4; // If zero; no expectation.
    TestAndSetCondition condition   = 5;
}

// Next tag to use: 4
message PutResponse {
    BucketInfo bucket_info        = 1;
    BucketId   remapped_bucket_id = 2;
    bool       was_found          = 3;
}

// Next tag to use: 2
message Update {
    bytes payload = 1;
}

// Next tag to use: 6
message UpdateRequest {
    Bucket bucket                 = 1;
    Update update                 = 2;
    uint64 new_timestamp          = 3;
    uint64 expected_old_timestamp = 4; // If zero; no expectation.
    TestAndSetCondition condition = 5;
}

// Next tag to use: 4
message UpdateResponse {
    BucketInfo bucket_info        = 1;
    BucketId   remapped_bucket_id = 2;
    uint64     updated_timestamp  = 3;
}

// Next tag to use: 5
message RemoveRequest {
    Bucket bucket                 = 1;
    bytes  document_id            = 2;
    uint64 new_timestamp          = 3;
    TestAndSetCondition condition = 4;
}

// Next tag to use: 4
message RemoveResponse {
    BucketInfo bucket_info        = 1;
    BucketId   remapped_bucket_id = 2;
    uint64     removed_timestamp  = 3;
}

// Next tag to use: 5
message GetRequest {
    Bucket bucket           = 1;
    bytes  document_id      = 2;
    bytes  field_set        = 3;
    uint64 before_timestamp = 4;
}

// Next tag to use: 5
message GetResponse {
    Document   document                = 1;
    uint64     last_modified_timestamp = 2;
    BucketInfo bucket_info             = 3;
    BucketId   remapped_bucket_id      = 4;
}

// TODO consider deprecation/removal if this is not used in practice.
message RevertRequest {
    Bucket   bucket               = 1;
    repeated uint64 revert_tokens = 2;
}

// Next tag to use: 3
message RevertResponse {
    BucketInfo bucket_info        = 1;
    BucketId   remapped_bucket_id = 2;
}

// Next tag to use: 3
message DeleteBucketRequest {
    Bucket     bucket               = 1;
    BucketInfo expected_bucket_info = 2;
}

// Next tag to use: 3
message DeleteBucketResponse {
    BucketInfo bucket_info       = 1;
    BucketId  remapped_bucket_id = 2;
}

// Next tag to use: 3
message CreateBucketRequest {
    Bucket bucket           = 1;
    bool   create_as_active = 2;
}

// Next tag to use: 3
message CreateBucketResponse {
    BucketInfo bucket_info        = 1;
    BucketId   remapped_bucket_id = 2;
}

// Next tag to use: 3
message MergeNode {
    uint32 index = 1;
    bool   source_only = 2;
}

// Next tag to use: 6
message MergeBucketRequest {
    Bucket             bucket                = 1;
    uint32             cluster_state_version = 2;
    uint64             max_timestamp         = 3;
    repeated MergeNode nodes                 = 4;
    repeated uint32    node_chain            = 5;
}

// Next tag to use: 2
message MergeBucketResponse {
    BucketId remapped_bucket_id = 1;
}

message MetaDiffEntry {
    uint64   timestamp   = 1;
    GlobalId gid         = 2;
    uint32   header_size = 3; // TODO one of these can be removed...!
    uint32   body_size   = 4;
    uint32   flags       = 5;
    uint32   has_mask    = 6;
}

message GetBucketDiffRequest {
    Bucket                 bucket        = 1;
    uint64                 max_timestamp = 2;
    repeated MergeNode     nodes         = 3;
    repeated MetaDiffEntry diff          = 4;
}

message GetBucketDiffResponse {
    BucketId remapped_bucket_id = 1;
    repeated MetaDiffEntry diff = 2;
}

message ApplyDiffEntry {
    MetaDiffEntry entry_meta = 1;
    bytes document_id = 2;
    bytes header_blob = 3; // TODO use singular blob
    bytes body_blob = 4;
}

message ApplyBucketDiffRequest {
    Bucket             bucket = 1;
    repeated MergeNode nodes  = 2;
    uint32 max_buffer_size = 3;
    repeated ApplyDiffEntry entries = 4;
}

message ApplyBucketDiffResponse {
    BucketId remapped_bucket_id = 1;
    repeated ApplyDiffEntry entries = 4;
}

message ExplicitBucketSet {
    // `Bucket` is not needed, as the space is inferred from the owning message.
    repeated BucketId bucket_ids = 2;
}

message AllBuckets {
    uint32 distributor_index = 1;
    bytes cluster_state = 2;
    bytes distribution_hash = 3;
}

message RequestBucketInfoRequest {
    BucketSpace bucket_space = 1;
    oneof request_for {
        ExplicitBucketSet explicit_bucket_set = 2;
        AllBuckets        all_buckets         = 3;
    }
    // TODO bucket info version requested
}

message BucketAndBucketInfo {
    fixed64 raw_bucket_id = 1;
    BucketInfo bucket_info = 2;
}

message RequestBucketInfoResponse {
    repeated BucketAndBucketInfo bucket_infos = 1;
}

message NotifyBucketChangeRequest {
    Bucket     bucket      = 1;
    BucketInfo bucket_info = 2;
}

message NotifyBucketChangeResponse {
    // Currently empty
}

message SplitBucketRequest {
    Bucket bucket         = 1;
    uint32 min_split_bits = 2;
    uint32 max_split_bits = 3;
    uint32 min_byte_size  = 4;
    uint32 min_doc_count  = 5;
}

message SplitBucketResponse {
    BucketId remapped_bucket_id = 1;
    repeated BucketAndBucketInfo split_info = 2;
}

message JoinBucketsRequest {
    Bucket bucket = 1;
    repeated BucketId source_buckets = 2;
    uint32 min_join_bits = 3;
}

message JoinBucketsResponse {
    BucketInfo bucket_info        = 1;
    BucketId   remapped_bucket_id = 2;
}
